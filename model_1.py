# -*- coding: utf-8 -*-
"""
Created on Fri Sep 29 16:33:09 2017

@author: hasee
"""

import csv
import cv2
import numpy as np
import keras.callbacks
from keras.models import Sequential
from keras.layers.core import Flatten,Dense
from keras.layers.convolutional import Conv2D
from keras.layers import Lambda,Cropping2D,Dropout
from keras import regularizers


import cv2
from scipy.misc import imresize


import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

FILEPATH = 'data/'
BALANCED_FILE = FILEPATH+'driving_log_balanced.csv'
ORIGINAL_FILE = FILEPATH+'driving_log.csv'
MODELPATH = FILEPATH+'model.h5'

df = pd.read_csv(ORIGINAL_FILE)
df.columns =['center', 'left', 'right', 'steering', 'throttle', 'brake', 'speed']
balanced = pd.DataFrame() 	# Balanced dataset
bins = 1000 				# N of bins
bin_n = 500			# N of examples to include in each bin (at most)

balanced_num =[]
start = 0
for end in np.linspace(0, 1, num=bins):  
    df_range = df[(np.absolute(df.steering) >= start) & (np.absolute(df.steering) < end)]
    range_n = min(bin_n, df_range.shape[0])
    balanced_num.append(range_n)
    if range_n != 0:
        balanced = pd.concat([balanced, df_range.sample(range_n)])
    start = end

balanced.to_csv(BALANCED_FILE, index=False)

def equal_Hist(img):
    # Equalization Histogram
    img_temp = img.copy()
    img_temp[:,:,0] = cv2.equalizeHist(img[:, :, 0])
    img_temp[:,:,1] = cv2.equalizeHist(img[:, :, 1])
    img_temp[:,:,2] = cv2.equalizeHist(img[:, :, 2])
    return img_temp

def crop(img, margin=0):
    return img[margin:(img.shape[0]-margin), margin:(img.shape[1]-margin)]

def blur(img):
    gb = cv2.GaussianBlur(img, (5,5), 20.0)
    return cv2.addWeighted(img, 2, gb, -1, 0)

def resize(image, new_size): 
    return imresize(image, new_size) 

def shadow(image):
    img = np.copy(image)
    h, w = image.shape[0], image.shape[1]
    [x1, x2] = np.random.choice(w, 2, replace=False)
    k = h / (x2 - x1)
    b = - k * x1
    for i in range(h):
        c = int((i - b) / k)
        img[i, :c, :] = (image[i, :c, :] * .5).astype(np.int32)
    return img


def random_gamma(image):
    """
    Random gamma correction is used as an alternative method changing the brightness of
    training images.
    http://www.pyimagesearch.com/2015/10/05/opencv-gamma-correction/
    :param image:
        Source image
    :return:
        New image generated by applying gamma correction to the source image
    """
    gamma = np.random.uniform(0.4, 1.5)
    inv_gamma = 1.0 / gamma
    table = np.array([((i / 255.0) ** inv_gamma) * 255
                      for i in np.arange(0, 256)]).astype("uint8")

    # apply gamma correction using the lookup table
    return cv2.LUT(image, table)


def process(img):
    result = random_gamma(img)
    result = shadow(result)
    #result = resize(result, (80, 160, 3))
    result = blur(result)
    
    #result = blur(img)
    result = equal_Hist(result)

    return result

lines=[]
with open(BALANCED_FILE) as csvfile:
    reader = csv.reader(csvfile)
    for line in reader:
        lines.append(line)
del lines[0]
images=[]
measurements=[]
images_flipped = []
measurements_flipped = []
angle_delta = 0.25
for line in lines:
    source_path_center = line[0]
    source_path_left = line[1]
    source_path_right = line[2]
    center = "data/IMG/" + source_path_center.split('/')[-1]
    left = "data/IMG/" + source_path_left.split('/')[-1]
    right = "data/IMG/" + source_path_right.split('/')[-1]

    image_center = cv2.cvtColor(cv2.imread(center),cv2.COLOR_BGR2RGB)
    image_left = cv2.cvtColor(cv2.imread(left),cv2.COLOR_BGR2RGB)
    image_right = cv2.cvtColor(cv2.imread(right),cv2.COLOR_BGR2RGB)

    processed_center = process(image_center)
    processed_left = process(image_left)
    processed_right = process(image_right)

    images.append(processed_center)
    images.append(processed_left)
    images.append(processed_right)

    measurement_center = float(line[3])
    measurement_left = measurement_center + angle_delta
    measurement_right = measurement_center - angle_delta

    measurements.append(measurement_center)
    measurements.append(measurement_left)
    measurements.append(measurement_right)

    #image_center_flipped = np.fliplr(image_center)
    #image_left_flipped = np.fliplr(image_left)
    #image_right_flipped = np.fliplr(image_right)

    #measurement_center_flipped = -measurement_center
    #measurement_left_flipped = -measurement_left
    #measurement_right_flipped = -measurement_right

    #images.append(image_center_flipped)
    #images.append(image_left_flipped)
    #images.append(image_right_flipped)

    #measurements.append(measurement_center_flipped)
    #measurements.append(measurement_left_flipped)
    #measurements.append(measurement_right_flipped)

X_train = np.array(images)
y_train = np.array(measurements)

model = Sequential()
model.add(Lambda(lambda x:(x/255.0)-0.5,input_shape=(160,320,3)))
model.add(Cropping2D(cropping=((70,25),(0,0))))
model.add(Conv2D(24,(5,5),strides=(2,2),activation='relu'))
model.add(Conv2D(36,(5,5),strides=(2,2),activation='relu'))
model.add(Dropout(0.2))
model.add(Conv2D(48,(5,5),strides=(2,2),activation='relu'))
model.add(Conv2D(64,(3,3),activation='relu'))
model.add(Dropout(0.2))
model.add(Conv2D(64,(3,3),activation='relu'))
model.add(Dropout(0.2))
model.add(Conv2D(150,(1,1),activation='relu'))

model.add(Flatten())
model.add(Dense(100,kernel_regularizer=regularizers.l2(0.2)))
model.add(Dense(50,kernel_regularizer=regularizers.l2(0.2)))
model.add(Dense(10,kernel_regularizer=regularizers.l2(0.2)))
model.add(Dense(1))

model.compile(loss='mse',optimizer='adam')
tb_cb = keras.callbacks.TensorBoard(log_dir="./logs",write_images=1,histogram_freq=1)
cbks=[tb_cb]

model_history = model.fit(X_train,y_train,validation_split=0.2,shuffle=True,epochs=5,callbacks=cbks)
model.save('model_123.h5')
print(model.summary())
